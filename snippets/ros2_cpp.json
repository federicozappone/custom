{
  "Publisher": {
    "prefix": "pub",
    "body": [
      "#include <chrono>",
      "#include <functional>",
      "#include <memory>",
      "#include <string>",
      "",
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"std_msgs/msg/string.hpp\"",
      "",
      "using namespace std::chrono_literals;",
      "",
      "/* This example creates a subclass of Node and uses std::bind() to register a",
      "* member function as a callback from the timer. */",
      "",
      "class MinimalPublisher : public rclcpp::Node",
      "{",
      "  public:",
      "    MinimalPublisher()",
      "    : Node(\"minimal_publisher\"), count_(0)",
      "    {",
      "      publisher_ = this->create_publisher<std_msgs::msg::String>(\"topic\", 10);",
      "      timer_ = this->create_wall_timer(",
      "      500ms, std::bind(&MinimalPublisher::timer_callback, this));",
      "    }",
      "",
      "  private:",
      "    void timer_callback()",
      "    {",
      "      auto message = std_msgs::msg::String();",
      "      message.data = \"Hello, world! \" + std::to_string(count_++);",
      "      RCLCPP_INFO(this->get_logger(), \"Publishing: '%s'\", message.data.c_str());",
      "      publisher_->publish(message);",
      "    }",
      "    rclcpp::TimerBase::SharedPtr timer_;",
      "    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;",
      "    size_t count_;",
      "};",
      "",
      "int main(int argc, char * argv[])",
      "{",
      "  rclcpp::init(argc, argv);",
      "  rclcpp::spin(std::make_shared<MinimalPublisher>());",
      "  rclcpp::shutdown();",
      "  return 0;",
      "}"
    ],
    "description": "Simple ROS2 C++ Publisher"
  },

  "Subscriber": {
    "prefix": "sub",
    "body": [
      "#include <memory>",
      "",
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"std_msgs/msg/string.hpp\"",
      "using std::placeholders::_1;",
      "",
      "class MinimalSubscriber : public rclcpp::Node",
      "{",
      "  public:",
      "    MinimalSubscriber()",
      "    : Node(\"minimal_subscriber\")",
      "    {",
      "      subscription_ = this->create_subscription<std_msgs::msg::String>(",
      "      \"topic\", 10, std::bind(&MinimalSubscriber::topic_callback, this, _1));",
      "    }",
      "",
      "  private:",
      "    void topic_callback(const std_msgs::msg::String::SharedPtr msg) const",
      "    {",
      "      RCLCPP_INFO(this->get_logger(), \"I heard: '%s'\", msg->data.c_str());",
      "    }",
      "    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;",
      "};",
      "",
      "int main(int argc, char * argv[])",
      "{",
      "  rclcpp::init(argc, argv);",
      "  rclcpp::spin(std::make_shared<MinimalSubscriber>());",
      "  rclcpp::shutdown();",
      "  return 0;",
      "}"
    ],
    "description": "Simple ROS2 C++ Subscriber"
  },

  "Service": {
    "prefix": "ser",
    "body": [
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"std_srvs/srv/empty.hpp\"",
      "",
      "class MyServiceNode : public rclcpp::Node",
      "{",
      "public:",
      "    MyServiceNode() : Node(\"my_service_node\")",
      "    {",
      "        // Create a service",
      "        service_ = this->create_service<std_srvs::srv::Empty>(",
      "            \"my_service\", std::bind(&MyServiceNode::onServiceRequest, this, std::placeholders::_1, std::placeholders::_2));",
      "    }",
      "",
      "private:",
      "    void onServiceRequest(const std::shared_ptr<std_srvs::srv::Empty::Request> request,",
      "                          std::shared_ptr<std_srvs::srv::Empty::Response> response)",
      "    {",
      "        // Handle the service request here",
      "        RCLCPP_INFO(this->get_logger(), \"Service called\");",
      "    }",
      "",
      "    rclcpp::Service<std_srvs::srv::Empty>::SharedPtr service_;",
      "};",
      "",
      "int main(int argc, char *argv[])",
      "{",
      "    rclcpp::init(argc, argv);",
      "    rclcpp::spin(std::make_shared<MyServiceNode>());",
      "    rclcpp::shutdown();",
      "    return 0;",
      "}"
    ],
    "description": "Simple ROS2 C++ Service"
  },

  "IK Service": {
    "prefix": "ik",
    "body": [
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"$WORKSPACE_NAME/srv/inverse_kinematics.hpp\"",
      "",
      "class InverseKinematicsServiceNode : public rclcpp::Node",
      "{",
      "public:",
      "    InverseKinematicsServiceNode() : Node(\"inverse_kinematics_service_node\")",
      "    {",
      "        inverse_kinematics_service_ = this->create_service<$WORKSPACE_NAME::srv::InverseKinematics>(",
      "            \"inverse_kinematics\",",
      "            std::bind(&InverseKinematicsServiceNode::onInverseKinematicsRequest, this, std::placeholders::_1, std::placeholders::_2));",
      "    }",
      "",
      "private:",
      "    void onInverseKinematicsRequest(",
      "        const std::shared_ptr<$WORKSPACE_NAME::srv::InverseKinematics::Request> request,",
      "        std::shared_ptr<$WORKSPACE_NAME::srv::InverseKinematics::Response> response)",
      "    {",
      "        response->j1 = 1.0;",
      "        response->j2 = 1.0;",
      "        response->j3 = 1.0;",
      "        response->j4 = 1.0;",
      "        response->j5 = 1.0;",
      "        response->j6 = 1.0;",
      "        ",
      "        RCLCPP_INFO(this->get_logger(), \"Inverse Kinematics Service called with x=%f, y=%f, z=%f\", request->x, request->y, request->z);",
      "    }",
      "",
      "    rclcpp::Service<$WORKSPACE_NAME::srv::InverseKinematics>::SharedPtr inverse_kinematics_service_;",
      "};",
      "",
      "int main(int argc, char *argv[])",
      "{",
      "    rclcpp::init(argc, argv);",
      "    rclcpp::spin(std::make_shared<InverseKinematicsServiceNode>());",
      "    rclcpp::shutdown();",
      "    return 0;",
      "}",
      "",
      "/**",
      " * Add the following lines to the CMakeLists.txt",
      "",
      "find_package(rclcpp REQUIRED)",
      "find_package(geometry_msgs REQUIRED)",
      "find_package(rosidl_default_generators REQUIRED)",
      "find_package($WORKSPACE_NAME REQUIRED)",
      "",
      "rosidl_generate_interfaces(${PROJECT_NAME}",
      "  \"srv/InverseKinematics.srv\"",
      "  DEPENDENCIES geometry_msgs",
      ")",
      "",
      "add_executable(ik_service src/ik_service.cpp)",
      "ament_target_dependencies(ik_service rclcpp geometry_msgs $WORKSPACE_NAME)",
      "",
      "install(TARGETS",
      "  ik_service",
      "  DESTINATION lib/${PROJECT_NAME})",
      "",
      " * Add the following lines within the <package> element of package.xml",
      "",
      "",
      "<depend>geometry_msgs</depend>",
      "<buildtool_depend>rosidl_default_generators</buildtool_depend>",
      "<exec_depend>rosidl_default_runtime</exec_depend>",
      "<member_of_group>rosidl_interface_packages</member_of_group>",
      "",
      "",
      " * Create the service definition file in $WORKSPACE_NAME/srv/InverseKinematics.srv",
      "",
      "",
      "float32 x",
      "float32 y",
      "float32 z",
      "---",
      "float32 j1",
      "float32 j2",
      "float32 j3",
      "float32 j4",
      "float32 j5",
      "float32 j6",
      "",
      "*/"
    ],
    "description": "Custom ROS2 Service"
  },

  "Frame Broadcaster": {
    "prefix": "frame_broadcaster",
    "body": [
      "#include <chrono>",
      "#include <functional>",
      "#include <memory>",
      "#include \"geometry_msgs/msg/transform_stamped.hpp\"",
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"tf2_ros/transform_broadcaster.h\"",
      "",
      "using namespace std::chrono_literals;",
      "",
      "class FixedFrameBroadcaster : public rclcpp::Node",
      "{",
      "public:",
      "  FixedFrameBroadcaster() : Node(\"fixed_frame_tf2_broadcaster\")",
      "  {",
      "    tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);",
      "    timer_ = this->create_wall_timer(",
      "        100ms, std::bind(&FixedFrameBroadcaster::broadcast_timer_callback, this));",
      "  }",
      "",
      "private:",
      "  void broadcast_timer_callback()",
      "  {",
      "    geometry_msgs::msg::TransformStamped t;",
      "",
      "    t.header.stamp = this->get_clock()->now();",
      "    t.header.frame_id = \"turtle1\";",
      "    t.child_frame_id = \"carrot1\";",
      "    t.transform.translation.x = 0.0;",
      "    t.transform.translation.y = 2.0;",
      "    t.transform.translation.z = 0.0;",
      "    t.transform.rotation.x = 0.0;",
      "    t.transform.rotation.y = 0.0;",
      "    t.transform.rotation.z = 0.0;",
      "    t.transform.rotation.w = 1.0;",
      "",
      "    tf_broadcaster_->sendTransform(t);",
      "  }",
      "",
      "  rclcpp::TimerBase::SharedPtr timer_;",
      "  std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;",
      "};",
      "",
      "int main(int argc, char* argv[])",
      "{",
      "  rclcpp::init(argc, argv);",
      "  rclcpp::spin(std::make_shared<FixedFrameBroadcaster>());",
      "  rclcpp::shutdown();",
      "  return 0;",
      "}"
    ],
    "description": "Simple Frame Broadcaster"
  },

  "Frame Listener": {
    "prefix": "frame_listener",
    "body": [
      "#include <chrono>",
      "#include <functional>",
      "#include <memory>",
      "#include <string>",
      "",
      "#include \"rclcpp/rclcpp.hpp\"",
      "",
      "#include \"geometry_msgs/msg/transform_stamped.hpp\"",
      "#include \"geometry_msgs/msg/twist.hpp\"",
      "",
      "#include \"tf2/exceptions.h\"",
      "#include \"tf2_ros/transform_listener.h\"",
      "#include \"tf2_ros/buffer.h\"",
      "",
      "#include \"eigen3/Eigen/Dense\"",
      "",
      "using namespace std::chrono_literals;",
      "",
      "class FrameListenerNode : public rclcpp::Node",
      "{",
      "public:",
      "  FrameListenerNode() : Node(\"frame_listener_node\")",
      "  {",
      "    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());",
      "    tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);",
      "",
      "    timer_ = this->create_wall_timer(1s, std::bind(&FrameListenerNode::on_timer, this));",
      "  }",
      "",
      "private:",
      "  std::shared_ptr<tf2_ros::TransformListener> tf_listener_;",
      "  std::unique_ptr<tf2_ros::Buffer> tf_buffer_;",
      "  rclcpp::TimerBase::SharedPtr timer_;",
      "",
      "  void on_timer()",
      "  {",
      "    Eigen::Matrix4d htrans = resolve_tf(\"camera_link\", \"base_link\", msg->header.stamp);",
      "    RCLCPP_INFO_STREAM(get_logger(), \"HTrans:\\n\" << htrans);",
      "  }",
      "",
      "  Eigen::Matrix4d resolve_tf(const std::string& target, const std::string& source,",
      "                             const rclcpp::Time time)",
      "  {",
      "    geometry_msgs::msg::TransformStamped tf_stamped;",
      "",
      "    try",
      "    {",
      "      tf_stamped = tf_buffer_->lookupTransform(target, source, time);",
      "",
      "      RCLCPP_INFO(get_logger(), \"Received transform: x=%f, y=%f, z=%f\",",
      "                  tf_stamped.transform.translation.x, tf_stamped.transform.translation.y,",
      "                  tf_stamped.transform.translation.z);",
      "    }",
      "    catch (tf2::TransformException& e)",
      "    {",
      "      RCLCPP_ERROR(get_logger(), \"Transform lookup failed: %s\", e.what());",
      "      // throw e;",
      "    }",
      "",
      "    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();",
      "",
      "    T.block(0, 3, 3, 1) << tf_stamped.transform.translation.x, tf_stamped.transform.translation.y,",
      "        tf_stamped.transform.translation.z;",
      "",
      "    Eigen::Quaterniond q(tf_stamped.transform.rotation.w, tf_stamped.transform.rotation.x,",
      "                         tf_stamped.transform.rotation.y, tf_stamped.transform.rotation.z);",
      "    T.block(0, 0, 3, 3) = q.toRotationMatrix();",
      "",
      "    return T;",
      "  }",
      "};",
      "",
      "int main(int argc, char* argv[])",
      "{",
      "  rclcpp::init(argc, argv);",
      "  rclcpp::spin(std::make_shared<FrameListenerNode>());",
      "  rclcpp::shutdown();",
      "  return 0;",
      "}",
      "",
      "/**",
      " * For Eigen3",
      "",
      "find_package(Eigen3 REQUIRED)",
      "",
      "*/"
    ],
    "description": "Simple Frame Broadcaster"
  },

  "Image Subscriber": {
    "prefix": "image_subscriber",
    "body": [
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"sensor_msgs/msg/image.hpp\"",
      "#include \"cv_bridge/cv_bridge.h\"",
      "#include \"opencv2/highgui/highgui.hpp\"",
      "",
      "class ImageDisplayNode : public rclcpp::Node",
      "{",
      "public:",
      "  ImageDisplayNode() : Node(\"image_display_node\")",
      "  {",
      "    auto qos = rclcpp::QoS(rclcpp::QoSInitialization(",
      "        // The history policy determines how messages are saved until taken by",
      "        // the reader.",
      "        // KEEP_ALL saves all messages until they are taken.",
      "        // KEEP_LAST enforces a limit on the number of messages that are saved,",
      "        // specified by the \"depth\" parameter.",
      "        history_policy_,",
      "        // Depth represents how many messages to store in history when the",
      "        // history policy is KEEP_LAST.",
      "        depth_));",
      "",
      "    qos.reliability(reliability_policy_);",
      "",
      "    // Subscribe to the image topic",
      "    image_subscription_ = this->create_subscription<sensor_msgs::msg::Image>(",
      "        \"/camera/image_raw\", qos, [this](const sensor_msgs::msg::Image::SharedPtr msg) {",
      "          // Convert the ROS image message to an OpenCV image",
      "          cv_bridge::CvImagePtr cv_image_ptr;",
      "          try",
      "          {",
      "            cv_image_ptr = cv_bridge::toCvCopy(msg, \"bgr8\");",
      "          }",
      "          catch (cv_bridge::Exception& e)",
      "          {",
      "            RCLCPP_ERROR(this->get_logger(), \"CV Bridge Error: %s\", e.what());",
      "            return;",
      "          }",
      "",
      "          cv::imshow(\"Received Image\", cv_image_ptr->image);",
      "          cv::waitKey(1);",
      "        });",
      "",
      "    RCLCPP_INFO(this->get_logger(), \"Image Display Node has started.\");",
      "  }",
      "",
      "private:",
      "  rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr image_subscription_;",
      "",
      "  size_t depth_ = rmw_qos_profile_default.depth;",
      "  rmw_qos_reliability_policy_t reliability_policy_ = rmw_qos_profile_default.reliability;",
      "  rmw_qos_history_policy_t history_policy_ = rmw_qos_profile_default.history;",
      "};",
      "",
      "int main(int argc, char** argv)",
      "{",
      "  rclcpp::init(argc, argv);",
      "  rclcpp::spin(std::make_shared<ImageDisplayNode>());",
      "  rclcpp::shutdown();",
      "  return 0;",
      "}",
      "",
      "/**",
      " * Add the following to the CMakeLists.txt",
      "",
      "find_package(sensor_msgs REQUIRED)",
      "find_package(cv_bridge REQUIRED)",
      "find_package(image_transport REQUIRED)",
      "find_package(OpenCV REQUIRED)",
      "",
      "# Create an executable for your node",
      "add_executable(image_display src/image_display.cpp)",
      "",
      "# Link your node with the necessary libraries",
      "ament_target_dependencies(image_display",
      "  rclcpp",
      "  sensor_msgs",
      "  cv_bridge",
      "  image_transport",
      "  OpenCV",
      ")",
      "",
      "*/"
    ],
    "description": "Simple Image Subscriber"
  },

  "Resolve TF": {
    "prefix": "resolve_tf",
    "body": [
      "  Eigen::Matrix4d resolve_tf(const std::string& target, const std::string& source,",
      "                             const rclcpp::Time time)",
      "  {",
      "    geometry_msgs::msg::TransformStamped tf_stamped;",
      "",
      "    try",
      "    {",
      "      tf_stamped = tf_buffer_->lookupTransform(target, source, time);",
      "",
      "      RCLCPP_INFO(get_logger(), \"Received transform: x=%f, y=%f, z=%f\",",
      "                  tf_stamped.transform.translation.x, tf_stamped.transform.translation.y,",
      "                  tf_stamped.transform.translation.z);",
      "    }",
      "    catch (tf2::TransformException& e)",
      "    {",
      "      RCLCPP_ERROR(get_logger(), \"Transform lookup failed: %s\", e.what());",
      "      // throw e;",
      "    }",
      "",
      "    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();",
      "",
      "    T.block(0, 3, 3, 1) << tf_stamped.transform.translation.x, tf_stamped.transform.translation.y,",
      "        tf_stamped.transform.translation.z;",
      "",
      "    Eigen::Quaterniond q(tf_stamped.transform.rotation.w, tf_stamped.transform.rotation.x,",
      "                         tf_stamped.transform.rotation.y, tf_stamped.transform.rotation.z);",
      "    T.block(0, 0, 3, 3) = q.toRotationMatrix();",
      "",
      "    return T;",
      "  }"
    ],
    "description": "Resolve ROS2 TF Utility"
  },

  "Log Info": {
    "prefix": "log_info",
    "body": [
      "RCLCPP_INFO(get_logger(), \"Message: %s\", value);"
    ],
    "description": "ROS2 Log Info"
  },

  "Log Warning": {
    "prefix": "log_warning",
    "body": [
      "RCLCPP_WARN(get_logger(), \"Message: %s\", value);"
    ],
    "description": "ROS2 Log Warning"
  },

  "Log Error": {
    "prefix": "log_error",
    "body": [
      "RCLCPP_ERROR(get_logger(), \"Message: %s\", value);"
    ],
    "description": "ROS2 Log Error"
  },

  "Log Stream": {
    "prefix": "log_stream",
    "body": [
      "RCLCPP_INFO_STREAM(get_logger(), \"Message: \" << value);"
    ],
    "description": "ROS2 Log Info Stream"
  }

}
